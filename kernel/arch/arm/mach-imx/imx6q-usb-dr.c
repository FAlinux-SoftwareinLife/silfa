#include <linux/of_platform.h>
#include <linux/gpio.h>
#include <linux/of.h> 
#include <linux/of_gpio.h>
#include <linux/delay.h>
#include <linux/workqueue.h>

#include <asm/io.h>
#include <asm/delay.h>
#include <mach/hardware.h>
#include <mach/mxc_ehci.h>

#define HW_ANADIG_USB1_CHRG_DETECT	(0x000001b0)
#define HW_ANADIG_USB1_CHRG_DETECT_SET	(0x000001b4)
#define HW_ANADIG_USB1_CHRG_DETECT_CLR	(0x000001b8)
#define HW_ANADIG_USB1_CHRG_DETECT_TOG	(0x000001bc)

#define BP_ANADIG_USB1_CHRG_DETECT_RSVD2      24
#define BM_ANADIG_USB1_CHRG_DETECT_RSVD2 0xFF000000
#define BF_ANADIG_USB1_CHRG_DETECT_RSVD2(v) \
	(((v) << 24) & BM_ANADIG_USB1_CHRG_DETECT_RSVD2)
#define BM_ANADIG_USB1_CHRG_DETECT_BGR_BIAS 0x00800000
#define BP_ANADIG_USB1_CHRG_DETECT_RSVD1      21
#define BM_ANADIG_USB1_CHRG_DETECT_RSVD1 0x00600000
#define BF_ANADIG_USB1_CHRG_DETECT_RSVD1(v)  \
	(((v) << 21) & BM_ANADIG_USB1_CHRG_DETECT_RSVD1)
#define BM_ANADIG_USB1_CHRG_DETECT_EN_B 0x00100000
#define BM_ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B 0x00080000
#define BM_ANADIG_USB1_CHRG_DETECT_CHK_CONTACT 0x00040000
#define BP_ANADIG_USB1_CHRG_DETECT_RSVD0      1
#define BM_ANADIG_USB1_CHRG_DETECT_RSVD0 0x0003FFFE
#define BF_ANADIG_USB1_CHRG_DETECT_RSVD0(v)  \
	(((v) << 1) & BM_ANADIG_USB1_CHRG_DETECT_RSVD0)
#define BM_ANADIG_USB1_CHRG_DETECT_FORCE_DETECT 0x00000001

#define HW_ANADIG_USB1_PLL_480_CTRL	(0x00000010)
#define HW_ANADIG_USB1_PLL_480_CTRL_SET	(0x00000014)
#define HW_ANADIG_USB1_PLL_480_CTRL_CLR	(0x00000018)
#define HW_ANADIG_USB1_PLL_480_CTRL_TOG	(0x0000001c)

#define BM_ANADIG_USB1_PLL_480_CTRL_LOCK 0x80000000
#define BP_ANADIG_USB1_PLL_480_CTRL_RSVD1      17
#define BM_ANADIG_USB1_PLL_480_CTRL_RSVD1 0x7FFE0000
#define BF_ANADIG_USB1_PLL_480_CTRL_RSVD1(v)  \
	(((v) << 17) & BM_ANADIG_USB1_PLL_480_CTRL_RSVD1)
#define BM_ANADIG_USB1_PLL_480_CTRL_BYPASS 0x00010000
#define BP_ANADIG_USB1_PLL_480_CTRL_BYPASS_CLK_SRC      14
#define BM_ANADIG_USB1_PLL_480_CTRL_BYPASS_CLK_SRC 0x0000C000
#define BF_ANADIG_USB1_PLL_480_CTRL_BYPASS_CLK_SRC(v)  \
	(((v) << 14) & BM_ANADIG_USB1_PLL_480_CTRL_BYPASS_CLK_SRC)
#define BV_ANADIG_USB1_PLL_480_CTRL_BYPASS_CLK_SRC__OSC_24M  0x0
#define BV_ANADIG_USB1_PLL_480_CTRL_BYPASS_CLK_SRC__ANACLK_1 0x1
#define BV_ANADIG_USB1_PLL_480_CTRL_BYPASS_CLK_SRC__ANACLK_2 0x2
#define BV_ANADIG_USB1_PLL_480_CTRL_BYPASS_CLK_SRC__XOR      0x3
#define BM_ANADIG_USB1_PLL_480_CTRL_ENABLE 0x00002000
#define BM_ANADIG_USB1_PLL_480_CTRL_POWER 0x00001000
#define BM_ANADIG_USB1_PLL_480_CTRL_HOLD_RING_OFF 0x00000800
#define BM_ANADIG_USB1_PLL_480_CTRL_DOUBLE_CP 0x00000400
#define BM_ANADIG_USB1_PLL_480_CTRL_HALF_CP 0x00000200
#define BM_ANADIG_USB1_PLL_480_CTRL_DOUBLE_LF 0x00000100
#define BM_ANADIG_USB1_PLL_480_CTRL_HALF_LF 0x00000080
#define BM_ANADIG_USB1_PLL_480_CTRL_EN_USB_CLKS 0x00000040
#define BM_ANADIG_USB1_PLL_480_CTRL_RSVD0 0x00000020
#define BP_ANADIG_USB1_PLL_480_CTRL_CONTROL0      2
#define BM_ANADIG_USB1_PLL_480_CTRL_CONTROL0 0x0000001C
#define BF_ANADIG_USB1_PLL_480_CTRL_CONTROL0(v)  \
	(((v) << 2) & BM_ANADIG_USB1_PLL_480_CTRL_CONTROL0)
#define BP_ANADIG_USB1_PLL_480_CTRL_DIV_SELECT      0
#define BM_ANADIG_USB1_PLL_480_CTRL_DIV_SELECT 0x00000003
#define BF_ANADIG_USB1_PLL_480_CTRL_DIV_SELECT(v)  \
	(((v) << 0) & BM_ANADIG_USB1_PLL_480_CTRL_DIV_SELECT)

/* usb phy registers */

#define HW_USBPHY_PWD	(0x00000000)
#define HW_USBPHY_PWD_SET	(0x00000004)
#define HW_USBPHY_PWD_CLR	(0x00000008)
#define HW_USBPHY_PWD_TOG	(0x0000000c)

#define BP_USBPHY_PWD_RSVD2      21
#define BM_USBPHY_PWD_RSVD2 0xFFE00000
#define BF_USBPHY_PWD_RSVD2(v) \
	(((v) << 21) & BM_USBPHY_PWD_RSVD2)
#define BM_USBPHY_PWD_RXPWDRX 0x00100000
#define BM_USBPHY_PWD_RXPWDDIFF 0x00080000
#define BM_USBPHY_PWD_RXPWD1PT1 0x00040000
#define BM_USBPHY_PWD_RXPWDENV 0x00020000
#define BP_USBPHY_PWD_RSVD1      13
#define BM_USBPHY_PWD_RSVD1 0x0001E000
#define BF_USBPHY_PWD_RSVD1(v)  \
	(((v) << 13) & BM_USBPHY_PWD_RSVD1)
#define BM_USBPHY_PWD_TXPWDV2I 0x00001000
#define BM_USBPHY_PWD_TXPWDIBIAS 0x00000800
#define BM_USBPHY_PWD_TXPWDFS 0x00000400
#define BP_USBPHY_PWD_RSVD0      0
#define BM_USBPHY_PWD_RSVD0 0x000003FF
#define BF_USBPHY_PWD_RSVD0(v)  \
	(((v) << 0) & BM_USBPHY_PWD_RSVD0)

#define HW_USBPHY_TX	(0x00000010)
#define HW_USBPHY_TX_SET	(0x00000014)
#define HW_USBPHY_TX_CLR	(0x00000018)
#define HW_USBPHY_TX_TOG	(0x0000001c)

#define BP_USBPHY_TX_RSVD5      29
#define BM_USBPHY_TX_RSVD5 0xE0000000
#define BF_USBPHY_TX_RSVD5(v) \
	(((v) << 29) & BM_USBPHY_TX_RSVD5)
#define BP_USBPHY_TX_USBPHY_TX_EDGECTRL      26
#define BM_USBPHY_TX_USBPHY_TX_EDGECTRL 0x1C000000
#define BF_USBPHY_TX_USBPHY_TX_EDGECTRL(v)  \
	(((v) << 26) & BM_USBPHY_TX_USBPHY_TX_EDGECTRL)
#define BM_USBPHY_TX_USBPHY_TX_SYNC_INVERT 0x02000000
#define BM_USBPHY_TX_USBPHY_TX_SYNC_MUX 0x01000000
#define BP_USBPHY_TX_RSVD4      22
#define BM_USBPHY_TX_RSVD4 0x00C00000
#define BF_USBPHY_TX_RSVD4(v)  \
	(((v) << 22) & BM_USBPHY_TX_RSVD4)
#define BM_USBPHY_TX_TXENCAL45DP 0x00200000
#define BM_USBPHY_TX_RSVD3 0x00100000
#define BP_USBPHY_TX_TXCAL45DP      16
#define BM_USBPHY_TX_TXCAL45DP 0x000F0000
#define BF_USBPHY_TX_TXCAL45DP(v)  \
	(((v) << 16) & BM_USBPHY_TX_TXCAL45DP)
#define BP_USBPHY_TX_RSVD2      14
#define BM_USBPHY_TX_RSVD2 0x0000C000
#define BF_USBPHY_TX_RSVD2(v)  \
	(((v) << 14) & BM_USBPHY_TX_RSVD2)
#define BM_USBPHY_TX_TXENCAL45DN 0x00002000
#define BM_USBPHY_TX_RSVD1 0x00001000
#define BP_USBPHY_TX_TXCAL45DN      8
#define BM_USBPHY_TX_TXCAL45DN 0x00000F00
#define BF_USBPHY_TX_TXCAL45DN(v)  \
	(((v) << 8) & BM_USBPHY_TX_TXCAL45DN)
#define BP_USBPHY_TX_RSVD0      4
#define BM_USBPHY_TX_RSVD0 0x000000F0
#define BF_USBPHY_TX_RSVD0(v)  \
	(((v) << 4) & BM_USBPHY_TX_RSVD0)
#define BP_USBPHY_TX_D_CAL      0
#define BM_USBPHY_TX_D_CAL 0x0000000F
#define BF_USBPHY_TX_D_CAL(v)  \
	(((v) << 0) & BM_USBPHY_TX_D_CAL)

#define HW_USBPHY_RX	(0x00000020)
#define HW_USBPHY_RX_SET	(0x00000024)
#define HW_USBPHY_RX_CLR	(0x00000028)
#define HW_USBPHY_RX_TOG	(0x0000002c)

#define BP_USBPHY_RX_RSVD2      23
#define BM_USBPHY_RX_RSVD2 0xFF800000
#define BF_USBPHY_RX_RSVD2(v) \
	(((v) << 23) & BM_USBPHY_RX_RSVD2)
#define BM_USBPHY_RX_RXDBYPASS 0x00400000
#define BP_USBPHY_RX_RSVD1      7
#define BM_USBPHY_RX_RSVD1 0x003FFF80
#define BF_USBPHY_RX_RSVD1(v)  \
	(((v) << 7) & BM_USBPHY_RX_RSVD1)
#define BP_USBPHY_RX_DISCONADJ      4
#define BM_USBPHY_RX_DISCONADJ 0x00000070
#define BF_USBPHY_RX_DISCONADJ(v)  \
	(((v) << 4) & BM_USBPHY_RX_DISCONADJ)
#define BM_USBPHY_RX_RSVD0 0x00000008
#define BP_USBPHY_RX_ENVADJ      0
#define BM_USBPHY_RX_ENVADJ 0x00000007
#define BF_USBPHY_RX_ENVADJ(v)  \
	(((v) << 0) & BM_USBPHY_RX_ENVADJ)

#define HW_USBPHY_CTRL	(0x00000030)
#define HW_USBPHY_CTRL_SET	(0x00000034)
#define HW_USBPHY_CTRL_CLR	(0x00000038)
#define HW_USBPHY_CTRL_TOG	(0x0000003c)

#define BM_USBPHY_CTRL_SFTRST 0x80000000
#define BM_USBPHY_CTRL_CLKGATE 0x40000000
#define BM_USBPHY_CTRL_UTMI_SUSPENDM 0x20000000
#define BM_USBPHY_CTRL_HOST_FORCE_LS_SE0 0x10000000
#define BM_USBPHY_CTRL_OTG_ID_VALUE 0x08000000
#define BM_USBPHY_CTRL_ENAUTOSET_USBCLKS 0x04000000
#define BM_USBPHY_CTRL_ENAUTOCLR_USBCLKGATE 0x02000000
#define BM_USBPHY_CTRL_FSDLL_RST_EN 0x01000000
#define BM_USBPHY_CTRL_ENVBUSCHG_WKUP 0x00800000
#define BM_USBPHY_CTRL_ENIDCHG_WKUP 0x00400000
#define BM_USBPHY_CTRL_ENDPDMCHG_WKUP 0x00200000
#define BM_USBPHY_CTRL_ENAUTOCLR_PHY_PWD 0x00100000
#define BM_USBPHY_CTRL_ENAUTOCLR_CLKGATE 0x00080000
#define BM_USBPHY_CTRL_ENAUTO_PWRON_PLL 0x00040000
#define BM_USBPHY_CTRL_WAKEUP_IRQ 0x00020000
#define BM_USBPHY_CTRL_ENIRQWAKEUP 0x00010000
#define BM_USBPHY_CTRL_ENUTMILEVEL3 0x00008000
#define BM_USBPHY_CTRL_ENUTMILEVEL2 0x00004000
#define BM_USBPHY_CTRL_DATA_ON_LRADC 0x00002000
#define BM_USBPHY_CTRL_DEVPLUGIN_IRQ 0x00001000
#define BM_USBPHY_CTRL_ENIRQDEVPLUGIN 0x00000800
#define BM_USBPHY_CTRL_RESUME_IRQ 0x00000400
#define BM_USBPHY_CTRL_ENIRQRESUMEDETECT 0x00000200
#define BM_USBPHY_CTRL_RESUMEIRQSTICKY 0x00000100
#define BM_USBPHY_CTRL_ENOTGIDDETECT 0x00000080
#define BM_USBPHY_CTRL_OTG_ID_CHG_IRQ 0x00000040
#define BM_USBPHY_CTRL_DEVPLUGIN_POLARITY 0x00000020
#define BM_USBPHY_CTRL_ENDEVPLUGINDETECT 0x00000010
#define BM_USBPHY_CTRL_HOSTDISCONDETECT_IRQ 0x00000008
#define BM_USBPHY_CTRL_ENIRQHOSTDISCON 0x00000004
#define BM_USBPHY_CTRL_ENHOSTDISCONDETECT 0x00000002
#define BM_USBPHY_CTRL_ENOTG_ID_CHG_IRQ 0x00000001

#define HW_USBPHY_STATUS	(0x00000040)

#define BP_USBPHY_STATUS_RSVD4      11
#define BM_USBPHY_STATUS_RSVD4 0xFFFFF800
#define BF_USBPHY_STATUS_RSVD4(v) \
	(((v) << 11) & BM_USBPHY_STATUS_RSVD4)
#define BM_USBPHY_STATUS_RESUME_STATUS 0x00000400
#define BM_USBPHY_STATUS_RSVD3 0x00000200
#define BM_USBPHY_STATUS_OTGID_STATUS 0x00000100
#define BM_USBPHY_STATUS_RSVD2 0x00000080
#define BM_USBPHY_STATUS_DEVPLUGIN_STATUS 0x00000040
#define BP_USBPHY_STATUS_RSVD1      4
#define BM_USBPHY_STATUS_RSVD1 0x00000030
#define BF_USBPHY_STATUS_RSVD1(v)  \
	(((v) << 4) & BM_USBPHY_STATUS_RSVD1)
#define BM_USBPHY_STATUS_HOSTDISCONDETECT_STATUS 0x00000008
#define BP_USBPHY_STATUS_RSVD0      0
#define BM_USBPHY_STATUS_RSVD0 0x00000007
#define BF_USBPHY_STATUS_RSVD0(v)  \
	(((v) << 0) & BM_USBPHY_STATUS_RSVD0)

#define HW_USBPHY_DEBUG	(0x00000050)
#define HW_USBPHY_DEBUG_SET	(0x00000054)
#define HW_USBPHY_DEBUG_CLR	(0x00000058)
#define HW_USBPHY_DEBUG_TOG	(0x0000005c)

#define BM_USBPHY_DEBUG_RSVD3 0x80000000
#define BM_USBPHY_DEBUG_CLKGATE 0x40000000
#define BM_USBPHY_DEBUG_HOST_RESUME_DEBUG 0x20000000
#define BP_USBPHY_DEBUG_SQUELCHRESETLENGTH      25
#define BM_USBPHY_DEBUG_SQUELCHRESETLENGTH 0x1E000000
#define BF_USBPHY_DEBUG_SQUELCHRESETLENGTH(v)  \
	(((v) << 25) & BM_USBPHY_DEBUG_SQUELCHRESETLENGTH)
#define BM_USBPHY_DEBUG_ENSQUELCHRESET 0x01000000
#define BP_USBPHY_DEBUG_RSVD2      21
#define BM_USBPHY_DEBUG_RSVD2 0x00E00000
#define BF_USBPHY_DEBUG_RSVD2(v)  \
	(((v) << 21) & BM_USBPHY_DEBUG_RSVD2)
#define BP_USBPHY_DEBUG_SQUELCHRESETCOUNT      16
#define BM_USBPHY_DEBUG_SQUELCHRESETCOUNT 0x001F0000
#define BF_USBPHY_DEBUG_SQUELCHRESETCOUNT(v)  \
	(((v) << 16) & BM_USBPHY_DEBUG_SQUELCHRESETCOUNT)
#define BP_USBPHY_DEBUG_RSVD1      13
#define BM_USBPHY_DEBUG_RSVD1 0x0000E000
#define BF_USBPHY_DEBUG_RSVD1(v)  \
	(((v) << 13) & BM_USBPHY_DEBUG_RSVD1)
#define BM_USBPHY_DEBUG_ENTX2RXCOUNT 0x00001000
#define BP_USBPHY_DEBUG_TX2RXCOUNT      8
#define BM_USBPHY_DEBUG_TX2RXCOUNT 0x00000F00
#define BF_USBPHY_DEBUG_TX2RXCOUNT(v)  \
	(((v) << 8) & BM_USBPHY_DEBUG_TX2RXCOUNT)
#define BP_USBPHY_DEBUG_RSVD0      6
#define BM_USBPHY_DEBUG_RSVD0 0x000000C0
#define BF_USBPHY_DEBUG_RSVD0(v)  \
	(((v) << 6) & BM_USBPHY_DEBUG_RSVD0)
#define BP_USBPHY_DEBUG_ENHSTPULLDOWN      4
#define BM_USBPHY_DEBUG_ENHSTPULLDOWN 0x00000030
#define BF_USBPHY_DEBUG_ENHSTPULLDOWN(v)  \
	(((v) << 4) & BM_USBPHY_DEBUG_ENHSTPULLDOWN)
#define BP_USBPHY_DEBUG_HSTPULLDOWN      2
#define BM_USBPHY_DEBUG_HSTPULLDOWN 0x0000000C
#define BF_USBPHY_DEBUG_HSTPULLDOWN(v)  \
	(((v) << 2) & BM_USBPHY_DEBUG_HSTPULLDOWN)
#define BM_USBPHY_DEBUG_DEBUG_INTERFACE_HOLD 0x00000002
#define BM_USBPHY_DEBUG_OTGIDPIOLOCK 0x00000001

#define HW_USBPHY_DEBUG0_STATUS	(0x00000060)

#define BP_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT      26
#define BM_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT 0xFC000000
#define BF_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT(v) \
	(((v) << 26) & BM_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT)
#define BP_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT      16
#define BM_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT 0x03FF0000
#define BF_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT(v)  \
	(((v) << 16) & BM_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT)
#define BP_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT      0
#define BM_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT 0x0000FFFF
#define BF_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT(v)  \
	(((v) << 0) & BM_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT)

#define HW_USBPHY_DEBUG1	(0x00000070)
#define HW_USBPHY_DEBUG1_SET	(0x00000074)
#define HW_USBPHY_DEBUG1_CLR	(0x00000078)
#define HW_USBPHY_DEBUG1_TOG	(0x0000007c)

#define BP_USBPHY_DEBUG1_RSVD1      15
#define BM_USBPHY_DEBUG1_RSVD1 0xFFFF8000
#define BF_USBPHY_DEBUG1_RSVD1(v) \
	(((v) << 15) & BM_USBPHY_DEBUG1_RSVD1)
#define BP_USBPHY_DEBUG1_ENTAILADJVD      13
#define BM_USBPHY_DEBUG1_ENTAILADJVD 0x00006000
#define BF_USBPHY_DEBUG1_ENTAILADJVD(v)  \
	(((v) << 13) & BM_USBPHY_DEBUG1_ENTAILADJVD)
#define BM_USBPHY_DEBUG1_ENTX2TX 0x00001000
#define BP_USBPHY_DEBUG1_RSVD0      4
#define BM_USBPHY_DEBUG1_RSVD0 0x00000FF0
#define BF_USBPHY_DEBUG1_RSVD0(v)  \
	(((v) << 4) & BM_USBPHY_DEBUG1_RSVD0)
#define BP_USBPHY_DEBUG1_DBG_ADDRESS      0
#define BM_USBPHY_DEBUG1_DBG_ADDRESS 0x0000000F
#define BF_USBPHY_DEBUG1_DBG_ADDRESS(v)  \
	(((v) << 0) & BM_USBPHY_DEBUG1_DBG_ADDRESS)

#define HW_USBPHY_VERSION	(0x00000080)

#define BP_USBPHY_VERSION_MAJOR      24
#define BM_USBPHY_VERSION_MAJOR 0xFF000000
#define BF_USBPHY_VERSION_MAJOR(v) \
	(((v) << 24) & BM_USBPHY_VERSION_MAJOR)
#define BP_USBPHY_VERSION_MINOR      16
#define BM_USBPHY_VERSION_MINOR 0x00FF0000
#define BF_USBPHY_VERSION_MINOR(v)  \
	(((v) << 16) & BM_USBPHY_VERSION_MINOR)
#define BP_USBPHY_VERSION_STEP      0
#define BM_USBPHY_VERSION_STEP 0x0000FFFF
#define BF_USBPHY_VERSION_STEP(v)  \
	(((v) << 0) & BM_USBPHY_VERSION_STEP)

#define HW_USBPHY_IP	(0x00000090)
#define HW_USBPHY_IP_SET	(0x00000094)
#define HW_USBPHY_IP_CLR	(0x00000098)
#define HW_USBPHY_IP_TOG	(0x0000009c)

#define BP_USBPHY_IP_RSVD1      25
#define BM_USBPHY_IP_RSVD1 0xFE000000
#define BF_USBPHY_IP_RSVD1(v) \
	(((v) << 25) & BM_USBPHY_IP_RSVD1)
#define BP_USBPHY_IP_DIV_SEL      23
#define BM_USBPHY_IP_DIV_SEL 0x01800000
#define BF_USBPHY_IP_DIV_SEL(v)  \
	(((v) << 23) & BM_USBPHY_IP_DIV_SEL)
#define BV_USBPHY_IP_DIV_SEL__DEFAULT   0x0
#define BV_USBPHY_IP_DIV_SEL__LOWER     0x1
#define BV_USBPHY_IP_DIV_SEL__LOWEST    0x2
#define BV_USBPHY_IP_DIV_SEL__UNDEFINED 0x3
#define BP_USBPHY_IP_LFR_SEL      21
#define BM_USBPHY_IP_LFR_SEL 0x00600000
#define BF_USBPHY_IP_LFR_SEL(v)  \
	(((v) << 21) & BM_USBPHY_IP_LFR_SEL)
#define BV_USBPHY_IP_LFR_SEL__DEFAULT   0x0
#define BV_USBPHY_IP_LFR_SEL__TIMES_2   0x1
#define BV_USBPHY_IP_LFR_SEL__TIMES_05  0x2
#define BV_USBPHY_IP_LFR_SEL__UNDEFINED 0x3
#define BP_USBPHY_IP_CP_SEL      19
#define BM_USBPHY_IP_CP_SEL 0x00180000
#define BF_USBPHY_IP_CP_SEL(v)  \
	(((v) << 19) & BM_USBPHY_IP_CP_SEL)
#define BV_USBPHY_IP_CP_SEL__DEFAULT   0x0
#define BV_USBPHY_IP_CP_SEL__TIMES_2   0x1
#define BV_USBPHY_IP_CP_SEL__TIMES_05  0x2
#define BV_USBPHY_IP_CP_SEL__UNDEFINED 0x3
#define BM_USBPHY_IP_TSTI_TX_DP 0x00040000
#define BM_USBPHY_IP_TSTI_TX_DM 0x00020000
#define BM_USBPHY_IP_ANALOG_TESTMODE 0x00010000
#define BP_USBPHY_IP_RSVD0      3
#define BM_USBPHY_IP_RSVD0 0x0000FFF8
#define BF_USBPHY_IP_RSVD0(v)  \
	(((v) << 3) & BM_USBPHY_IP_RSVD0)
#define BM_USBPHY_IP_EN_USB_CLKS 0x00000004
#define BM_USBPHY_IP_PLL_LOCKED 0x00000002
#define BM_USBPHY_IP_PLL_POWER 0x00000001



void imx6q_usbdr_pm_init(void)
{
	void __iomem *anatop_base;
	anatop_base = IMX_IO_ADDRESS(MX6Q_ANATOP_BASE_ADDR);
	/* Some phy and power's special controls for otg
	 * 1. The external charger detector needs to be disabled
	 * or the signal at DP will be poor
	 * 2. The EN_USB_CLKS is always enabled.
	 * The PLL's power is controlled by usb and others who
	 * use pll3 too.
	 */
	writel_relaxed(BM_ANADIG_USB1_CHRG_DETECT_EN_B  \
			| BM_ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B,  \
			anatop_base + HW_ANADIG_USB1_CHRG_DETECT);
	writel_relaxed(BM_ANADIG_USB1_PLL_480_CTRL_EN_USB_CLKS,
			anatop_base + HW_ANADIG_USB1_PLL_480_CTRL_SET);
}

static void usbdr_internal_phy_clock_gate(bool on)
{
	void __iomem *phy_reg = IMX_IO_ADDRESS(MX6Q_USB_PHY1_BASE_ADDR);
	if (on) {
		writel_relaxed(BM_USBPHY_CTRL_CLKGATE, phy_reg + HW_USBPHY_CTRL_CLR);
	} else {
		writel_relaxed(BM_USBPHY_CTRL_CLKGATE, phy_reg + HW_USBPHY_CTRL_SET);
	}
}

static int usb_phy_enable(struct mxc_usbh_platform_data *pdata, void __iomem *regs)
{
	u32 tmp;
	void __iomem *phy_reg = IMX_IO_ADDRESS(MX6Q_USB_PHY1_BASE_ADDR);
	void __iomem *otg_reg = IMX_IO_ADDRESS(MX6Q_USB_OTGCTRL_BASE_ADDR);
	void __iomem *phy_ctrl;
#define UCMD_RUN_STOP           (1 << 0)
#define UCMD_RESET              (1 << 1)
#define USBCMD			0x140
	/* Stop then Reset */
	tmp = readl_relaxed(regs + USBCMD);
	tmp &= ~UCMD_RUN_STOP;
	writel_relaxed(tmp, regs + USBCMD);
	while (readl_relaxed(regs + USBCMD) & UCMD_RUN_STOP)
		;

	tmp = readl_relaxed(regs + USBCMD);
	tmp |= UCMD_RESET;
	writel_relaxed(tmp, regs + USBCMD);
	while (readl_relaxed(regs + USBCMD) & (UCMD_RESET))
		;

#define OTG_CTRL	0x0
#define UCTRL_OVER_CUR_POL      (1 << 8)        /* OTG Polarity of Overcurrent */
#define UCTRL_OVER_CUR_DIS      (1 << 7)        /* Disable OTG Overcurrent Detection */

	tmp = readl_relaxed(otg_reg + OTG_CTRL);
	tmp |= UCTRL_OVER_CUR_POL;
	tmp |= UCTRL_OVER_CUR_DIS;
	writel_relaxed(tmp, otg_reg +OTG_CTRL);

	/* Reset USBPHY module */
	phy_ctrl = phy_reg + HW_USBPHY_CTRL;
	tmp = readl_relaxed(phy_ctrl);
	tmp |= BM_USBPHY_CTRL_SFTRST;
	writel_relaxed(tmp, phy_ctrl);
	udelay(10);

	/* Remove CLKGATE and SFTRST */
	tmp = readl_relaxed(phy_ctrl);
	tmp &= ~(BM_USBPHY_CTRL_CLKGATE | BM_USBPHY_CTRL_SFTRST);
	writel_relaxed(tmp, phy_ctrl);
	udelay(10);

	/* Power up the PHY */
	writel_relaxed(0, phy_reg + HW_USBPHY_PWD);
	/* enable FS/LS device */
	tmp = readl_relaxed(phy_reg + HW_USBPHY_CTRL);
	tmp |= (BM_USBPHY_CTRL_ENUTMILEVEL2 | BM_USBPHY_CTRL_ENUTMILEVEL3);
	writel_relaxed(tmp, phy_reg + HW_USBPHY_CTRL);

	return 0;
}

static int imx6q_usbdr_init(struct platform_device *pdev, void __iomem *regs)
{
	int otg_pwr, err;

	otg_pwr = of_get_named_gpio(pdev->dev.of_node, "otg-pwr-gpios", 0);
	if (otg_pwr < 0) {
		printk(KERN_ERR "get gpio 'otg-pwr-gpios' fails\n");
		return -EINVAL;
	}
	err = gpio_request_one(otg_pwr, GPIOF_OUT_INIT_LOW, "otg-pwr");
	if (err) {
		printk(KERN_ERR "request gpio 'otg-pwr' fails\n");
		return -EINVAL;
	}
	/* Comment below code if OTG is supported */
	gpio_set_value(otg_pwr, 1);

	usbdr_internal_phy_clock_gate(true);
	usb_phy_enable(NULL, regs);
	return 0;
}

struct mxc_usbh_platform_data imx6q_usbdr_pdata = {
	.portsc = MXC_EHCI_MODE_UTMI,
	.init = imx6q_usbdr_init,
};

/* enable/disable high-speed disconnect detector of phy ctrl */
void fsl_platform_set_usb_phy_dis(bool enable)
{
	void __iomem *phy_regs = IMX_IO_ADDRESS(MX6Q_USB_PHY1_BASE_ADDR);
        if (enable)
                __raw_writel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,
                        (phy_regs) + HW_USBPHY_CTRL_SET);
        else
                __raw_writel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,
                        (phy_regs) + HW_USBPHY_CTRL_CLR);
}
EXPORT_SYMBOL(fsl_platform_set_usb_phy_dis);    
